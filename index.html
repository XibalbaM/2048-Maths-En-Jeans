<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>2048 — Jeu local (2 joueurs)</title>
  <style>
    :root{
      --size: 4;
      --cell-size: 90px;
      --gap: 12px;
      --board-bg: #bbada0;
      --cell-bg: #cdc1b4;
      --tile-radius: 8px;
      --font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    }
    *{box-sizing:border-box}
    body{display:flex;min-height:100vh;align-items:center;justify-content:center;padding:20px;background:#f0eadf;font-family:var(--font-family)}
    .container{width: calc(var(--cell-size) * var(--size) + var(--gap) * (var(--size) - 1) + 40px);}

    header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
    h1{font-size:28px;margin:0}
    .controls{display:flex;gap:10px;align-items:center}
    button{background:#8f7a66;border:none;color:white;padding:8px 12px;border-radius:6px;cursor:pointer;font-weight:600}
    button:hover{filter:brightness(1.05)}
    .scorebox{background:#eee;padding:8px 12px;border-radius:6px;min-width:86px;text-align:center}
    .small{font-size:12px;color:#6b5b4c}

    .board{position:relative;padding:20px;background:var(--board-bg);border-radius:12px;display:inline-block}
    .grid{display:grid;grid-template-columns:repeat(var(--size), var(--cell-size));grid-gap:var(--gap)}
    .cell{width:var(--cell-size);height:var(--cell-size);background:var(--cell-bg);border-radius:var(--tile-radius)}

    /* tiles (absolute on top of grid) */
    .tile-layer{position:absolute;left:20px;top:20px;pointer-events:none;width:calc(var(--cell-size) * var(--size) + var(--gap) * (var(--size) - 1));height:calc(var(--cell-size) * var(--size) + var(--gap) * (var(--size) - 1));}
    .tile{position:absolute;width:var(--cell-size);height:var(--cell-size);display:flex;align-items:center;justify-content:center;border-radius:var(--tile-radius);font-weight:700;font-size:24px;transition:transform 120ms ease, top 120ms ease, left 120ms ease, opacity 120ms ease;}
    .tile.new{transform:scale(0.2);opacity:0}
    .tile.show{transform:scale(1);opacity:1}
    .tile.merged{animation: pop 150ms ease}
    @keyframes pop{0%{transform:scale(1.1)}50%{transform:scale(0.95)}100%{transform:scale(1)}}

    /* tile colors */
    .t-2{background:#eee4da;color:#776e65}
    .t-4{background:#ede0c8;color:#776e65}
    .t-8{background:#f2b179;color:#f9f6f2}
    .t-16{background:#f59563;color:#f9f6f2}
    .t-32{background:#f67c5f;color:#f9f6f2}
    .t-64{background:#f65e3b;color:#f9f6f2}
    .t-128{background:#edcf72;color:#f9f6f2;font-size:20px}
    .t-256{background:#edcc61;color:#f9f6f2;font-size:20px}
    .t-512{background:#edc850;color:#f9f6f2;font-size:20px}
    .t-1024{background:#edc53f;color:#f9f6f2;font-size:18px}
    .t-2048{background:#edc22e;color:#f9f6f2;font-size:18px}

    .overlay{position:absolute;inset:0;background:rgba(238,228,218,0.85);display:flex;align-items:center;justify-content:center;border-radius:12px;flex-direction:column;padding:18px}
    .overlay p{margin:8px 0;font-size:18px}
    .placement-panel{display:flex;gap:12px;align-items:flex-start}
    .placement-values{display:flex;flex-direction:column;gap:8px}
    .value-btn{padding:8px 12px;border-radius:6px;border:none;cursor:pointer;font-weight:700}

    .footer{margin-top:12px;font-size:13px;color:#6b5b4c}

    .picker-grid{display:grid;grid-template-columns:repeat(var(--size), 48px);grid-gap:6px}
    .picker-cell{width:48px;height:48px;background:#e7e0d6;border-radius:6px;display:flex;align-items:center;justify-content:center;cursor:pointer}
    .picker-cell.empty{background:#fff}
    .picker-cell.selected{outline:3px solid #8f7a66}

    /* responsive */
    @media (max-width:480px){:root{--cell-size:64px}}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>2048 — joueur 1 vs joueur 2</h1>
      <div class="controls">
        <div class="scorebox">
          <div class="small">Score</div>
          <div id="score">0</div>
        </div>
        <div class="scorebox">
          <div class="small">Best</div>
          <div id="best">0</div>
        </div>
        <button id="newgame">Nouvelle partie</button>
      </div>
    </header>

    <div class="board" id="board" tabindex="0">
      <div class="grid" id="grid">
        <!-- cellules visuelles -->
      </div>
      <div class="tile-layer" id="tile-layer"></div>
    </div>

    <div class="footer">Joueur 1 contrôle les déplacements (flèches / ZQSD / glisser). Joueur 2 choisit où et quelle valeur (configurable).</div>
  </div>

  <script>
    /**
     * Version modulaire : l'ajout aléatoire est remplacé par un second joueur
     * qui choisit emplacement et valeur (parmi CONFIG.TILE_VALUES).
     *
     * Pour modifier les valeurs disponibles ou désactiver le mode 2e joueur,
     * changer l'objet CONFIG ci-dessous.
     */

    const CONFIG = {
      SIZE: 4,
      STORAGE_KEY: 'local2048_v2',
      TILE_VALUES: [2, 4], // <-- modifiez ici facilement
      SECOND_PLAYER_ENABLED: true, // passer à false pour revenir à l'ajout aléatoire
      INITIAL_PLACEMENTS: 2 // nombre de placements par le joueur 2 au démarrage
    };

    // State
    let grid = [];
    let score = 0;
    let best = 0;

    // DOM
    const gridEl = document.getElementById('grid');
    const tileLayer = document.getElementById('tile-layer');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const newBtn = document.getElementById('newgame');
    const boardEl = document.getElementById('board');

    // init CSS size var
    document.documentElement.style.setProperty('--size', CONFIG.SIZE);

    // helpers
    function copyGrid(g){ return g.map(row => row.slice()); }
    function resetGrid(){ grid = Array.from({length:CONFIG.SIZE}, ()=>Array.from({length:CONFIG.SIZE}, ()=>0)); }

    function saveState(){
      localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify({grid,score,best}));
    }
    function loadState(){
      try{
        const raw = localStorage.getItem(CONFIG.STORAGE_KEY);
        if(!raw) return false;
        const obj = JSON.parse(raw);
        if(obj && obj.grid) { grid = obj.grid; score = obj.score || 0; best = obj.best || 0; return true }
      }catch(e){console.warn(e)}
      return false;
    }

    // Basic tile setter (modulaire)
    function addTileAt(r,c,value){
      if(grid[r][c]!==0) return false;
      grid[r][c] = value;
      return true;
    }

    // Old random fallback (used if SECOND_PLAYER_ENABLED=false)
    function addRandomTile(){
      const empties = [];
      for(let r=0;r<CONFIG.SIZE;r++) for(let c=0;c<CONFIG.SIZE;c++) if(grid[r][c]===0) empties.push([r,c]);
      if(empties.length===0) return false;
      const [r,c] = empties[Math.floor(Math.random()*empties.length)];
      const v = Math.random() < 0.9 ? CONFIG.TILE_VALUES[0] : (CONFIG.TILE_VALUES[1]||CONFIG.TILE_VALUES[0]);
      grid[r][c] = v;
      return {r,c,value:v};
    }

    // Rotation utilities
    function rotate(g, times=1){
      let res = copyGrid(g);
      for(let t=0;t<times;t++){
        const tmp = Array.from({length:CONFIG.SIZE}, ()=>Array(CONFIG.SIZE).fill(0));
        for(let r=0;r<CONFIG.SIZE;r++) for(let c=0;c<CONFIG.SIZE;c++) tmp[c][CONFIG.SIZE-1-r] = res[r][c];
        res = tmp;
      }
      return res;
    }

    function moveLeftOnce(g){
      let moved = false; let mergedScore = 0;
      const out = Array.from({length:CONFIG.SIZE}, ()=>Array(CONFIG.SIZE).fill(0));
      for(let r=0;r<CONFIG.SIZE;r++){
        let pos = 0;
        for(let c=0;c<CONFIG.SIZE;c++){
          const val = g[r][c];
          if(val===0) continue;
          if(out[r][pos]===0) { out[r][pos]=val; if(c!==pos) moved = true; }
          else if(out[r][pos]===val){ out[r][pos]*=2; mergedScore += out[r][pos]; out[r][pos+1]=0; pos++; moved=true; }
          else { pos++; out[r][pos]=val; if(c!==pos) moved = true; }
        }
      }
      return {grid:out,moved,mergedScore};
    }

    function canMove(g){
      for(let r=0;r<CONFIG.SIZE;r++) for(let c=0;c<CONFIG.SIZE;c++){
        if(g[r][c]===0) return true;
        if(c+1<CONFIG.SIZE && g[r][c]===g[r][c+1]) return true;
        if(r+1<CONFIG.SIZE && g[r][c]===g[r+1][c]) return true;
      }
      return false;
    }

    // Movement wrapper — mapping directions to rotations (corrected)
    function rotatedForDirection(direction){
      // left:0, up:3, right:2, down:1  (mapping chosen so that moveLeftOnce handles left)
      if(direction==='left') return 0;
      if(direction==='up') return 3;
      if(direction==='right') return 2;
      if(direction==='down') return 1;
      return 0;
    }

    // Core move function now async because after a move we may wait for player 2
    async function move(direction){
      const rotatedTimes = rotatedForDirection(direction);
      let working = rotate(grid, rotatedTimes);
      const result = moveLeftOnce(working);
      if(!result.moved) return false;
      working = result.grid;
      working = rotate(working, (4-rotatedTimes)%4);
      grid = working;
      score += result.mergedScore;
      if(score > best) best = score;
      saveState();

      // After player 1 move: ask player 2 to place (unless disabled)
      if(CONFIG.SECOND_PLAYER_ENABLED){
        await promptSecondPlayer(1);
      } else {
        addRandomTile();
      }
      saveState();
      render();
      return true;
    }

    // RENDER
    function render(){
      scoreEl.textContent = score;
      bestEl.textContent = best;
      localStorage.setItem('best2048', best);
      // grid visuals
      gridEl.innerHTML = '';
      for(let r=0;r<CONFIG.SIZE;r++){
        for(let c=0;c<CONFIG.SIZE;c++){
          const cell = document.createElement('div');
          cell.className = 'cell';
          gridEl.appendChild(cell);
        }
      }

      // tiles
      tileLayer.innerHTML = '';
      const cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size'));
      const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap'));
      for(let r=0;r<CONFIG.SIZE;r++){
        for(let c=0;c<CONFIG.SIZE;c++){
          const val = grid[r][c];
          if(val===0) continue;
          const tile = document.createElement('div');
          tile.className = 'tile t-' + val;
          tile.textContent = val;
          const topPx = r * (cellSize + gap);
          const leftPx = c * (cellSize + gap);
          tile.style.top = topPx + 'px';
          tile.style.left = leftPx + 'px';
          tileLayer.appendChild(tile);
          requestAnimationFrame(()=>{ tile.classList.add('show'); });
        }
      }

      // win/lose
      if(grid.some(row=>row.some(v=>v===2048))){
        showOverlay('Bravo — vous avez atteint 2048 !', 'Continuer', ()=>{});
      } else if(!canMove(grid)){
        showOverlay('Partie terminée — plus de mouvements', 'Nouvelle partie', ()=>{ newGame(); });
      }
    }

    function showOverlay(text, btnText, btnCallback){
      const overlay = document.createElement('div');
      overlay.className = 'overlay';
      const p = document.createElement('p'); p.textContent = text;
      const btn = document.createElement('button'); btn.textContent = btnText;
      btn.onclick = ()=>{ overlay.remove(); if(btnCallback) btnCallback(); };
      overlay.appendChild(p); overlay.appendChild(btn);
      boardEl.appendChild(overlay);
    }

    // ----- Second player placement UI (modulaire) -----
    // Prompt player to place `count` tiles. Returns a Promise that resolves when done.
    function promptSecondPlayer(count=1){
      return new Promise((resolve)=>{
        // create overlay with a small picker
        const overlay = document.createElement('div');
        overlay.className = 'overlay';

        const title = document.createElement('p');
        title.textContent = `Joueur 2 — placez ${count} tuile(s). Choisissez une case vide puis une valeur.`;

        const panel = document.createElement('div');
        panel.className = 'placement-panel';

        // picker grid
        const pickerGrid = document.createElement('div');
        pickerGrid.className = 'picker-grid';
        pickerGrid.style.setProperty('--size', CONFIG.SIZE);

        // collect empties
        const empties = [];
        for(let r=0;r<CONFIG.SIZE;r++) for(let c=0;c<CONFIG.SIZE;c++) if(grid[r][c]===0) empties.push([r,c]);

        // build cells (clickable)
        const cellEls = [];
        for(let r=0;r<CONFIG.SIZE;r++){
          for(let c=0;c<CONFIG.SIZE;c++){
            const el = document.createElement('div');
            el.className = 'picker-cell';
            if(grid[r][c]===0){ el.classList.add('empty'); el.textContent = ''; }
            else el.textContent = grid[r][c];
            el.dataset.r = r; el.dataset.c = c;
            pickerGrid.appendChild(el);
            cellEls.push(el);
          }
        }

        // values area
        const valuesDiv = document.createElement('div');
        valuesDiv.className = 'placement-values';
        const info = document.createElement('div');
        info.textContent = 'Valeurs disponibles :';
        valuesDiv.appendChild(info);
        const valueButtons = [];
        CONFIG.TILE_VALUES.forEach(v=>{
          const b = document.createElement('button');
          b.className = 'value-btn';
          b.textContent = v;
          b.dataset.value = v;
          valuesDiv.appendChild(b);
          valueButtons.push(b);
        });

        // current selection
        let selectedCell = null;
        let placementsLeft = count;

        function clearSelection(){
          selectedCell = null;
          cellEls.forEach(el=>el.classList.remove('selected'));
        }

        // click on picker cell
        cellEls.forEach(el=>{
          el.addEventListener('click', ()=>{
            const r = parseInt(el.dataset.r), c = parseInt(el.dataset.c);
            if(grid[r][c]!==0) return; // only empty
            clearSelection();
            el.classList.add('selected');
            selectedCell = [r,c];
          });
        });

        // value buttons
        valueButtons.forEach(b=>{
          b.addEventListener('click', ()=>{
            if(!selectedCell){
              b.animate([{transform:'translateY(-4px)'},{transform:'translateY(0)'}],{duration:120});
              return; // need to choose a cell first
            }
            const r = selectedCell[0], c = selectedCell[1];
            const v = parseInt(b.dataset.value);
            addTileAt(r,c,v);
            placementsLeft--;
            clearSelection();
            // update picker visuals
            pickerGrid.querySelectorAll('.picker-cell').forEach(cell=>{
              const rr = parseInt(cell.dataset.r), cc = parseInt(cell.dataset.c);
              if(grid[rr][cc]===0){ cell.classList.add('empty'); cell.textContent = ''; }
              else { cell.classList.remove('empty'); cell.textContent = grid[rr][cc]; }
            });
            if(placementsLeft<=0){
              overlay.remove();
              render();
              resolve();
            } else {
              title.textContent = `Joueur 2 — placez ${placementsLeft} tuile(s). Choisissez une case vide puis une valeur.`;
            }
          });
        });

        // cancel button (allows undoing placement sequence)
        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Annuler';
        cancelBtn.onclick = ()=>{
          overlay.remove();
          resolve();
        };

        panel.appendChild(pickerGrid);
        panel.appendChild(valuesDiv);
        panel.appendChild(cancelBtn);

        overlay.appendChild(title);
        overlay.appendChild(panel);
        boardEl.appendChild(overlay);
      });
    }

    // NEW GAME
    async function newGame(){
      resetGrid(); score = 0; best = Number(localStorage.getItem('best2048')||0);
      saveState();
      render();
      if(CONFIG.SECOND_PLAYER_ENABLED){
        await promptSecondPlayer(CONFIG.INITIAL_PLACEMENTS);
        saveState();
        render();
      } else {
        addRandomTile(); addRandomTile();
        saveState(); render();
      }
    }

    // Keyboard & touch
    window.addEventListener('keydown', async (e)=>{
      const key = e.key;
      let moved = false;
      if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(key)) e.preventDefault();
      if(key === 'ArrowLeft' || key==='a' || key==='A') moved = await move('left');
      if(key === 'ArrowRight' || key==='d' || key==='D') moved = await move('right');
      if(key === 'ArrowUp' || key==='w' || key==='W' || key==='z' || key==='Z') moved = await move('up');
      if(key === 'ArrowDown' || key==='s' || key==='S') moved = await move('down');

      if(moved) saveState();
    });

    // touch swipe support
    let touchStartX=0,touchStartY=0;
    boardEl.addEventListener('touchstart',(e)=>{ if(e.touches.length===1){ touchStartX=e.touches[0].clientX; touchStartY=e.touches[0].clientY } });
    boardEl.addEventListener('touchend', async (e)=>{
      if(!touchStartX) return;
      const dx = (e.changedTouches[0].clientX - touchStartX);
      const dy = (e.changedTouches[0].clientY - touchStartY);
      const absX = Math.abs(dx), absY = Math.abs(dy);
      if(Math.max(absX,absY) > 20){
        if(absX > absY){ if(dx>0) await move('right'); else await move('left'); }
        else { if(dy>0) await move('down'); else await move('up'); }
        saveState();
      }
      touchStartX=0; touchStartY=0;
    });

    newBtn.addEventListener('click', ()=>{ newGame(); });

    // Init
    async function init(){
      document.documentElement.style.setProperty('--size', CONFIG.SIZE);
      if(!loadState()){
        resetGrid(); score = 0; best = Number(localStorage.getItem('best2048')||0);
        saveState();
      }
      render();
      // if empty grid and second player enabled, force initial placements
      const isEmpty = grid.every(row=>row.every(v=>v===0));
      if(isEmpty){
        if(CONFIG.SECOND_PLAYER_ENABLED){
          await promptSecondPlayer(CONFIG.INITIAL_PLACEMENTS);
          saveState(); render();
        } else {
          addRandomTile(); addRandomTile(); saveState(); render();
        }
      }
    }

    init();
  </script>
</body>
</html>
